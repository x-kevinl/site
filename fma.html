<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>F=ma Practice</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 800px;
      margin: 2em auto;
      padding: 0 1em;
    }
    #problem-container { text-align: center; }
    h1 { margin-bottom: 0.2em; }
    /* Timer styling */
    #timer {
      font-size: 1.2em;
      font-weight: bold;
      margin-bottom: 1em;
      color: #333;
    }
    #exam-label {
      margin-bottom: 0.5em;
      color: gray;
      font-style: italic;
    }

    /* Practice toggle */
    #practice-toggle-container {
      margin-bottom: 1em;
      text-align: center;
    }

    /* Problem and previous wrappers */
    #image-wrapper, #previous-wrapper {
      width: 90%;
      max-width: 800px;
      margin: 0 auto 1em;
      border: 2px solid #000;
      padding: 0.5em;
      box-sizing: border-box;
      min-height: 100px;
      position: relative;
    }
    #previous-wrapper {
      border-color: #ccc;
      display: none;
      text-align: left;
    }
    .problem-image {
      display: block;
      width: 100%;
      height: auto;
      margin-bottom: 1em;
    }
    .prev-section {
      margin-bottom: 1em;
    }
    .prev-title {
      font-weight: bold;
      margin-bottom: 0.5em;
    }

    #answer-box { margin-top: 1em; }
    #answer-box input {
      width: 60%; padding: 0.5em; font-size: 1em;
      text-transform: uppercase;
    }
    #answer-box button {
      padding: 0.5em 1em; font-size: 1em; margin-left: 0.5em;
    }
    #feedback { margin-top: 1em; font-weight: bold; }

    /* Loader animation */
    .loader {
      width: 15px;
      aspect-ratio: 1;
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      animation: l9-0 1.5s infinite steps(2);
    }
    .loader::before,
    .loader::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background: #000;
    }
    .loader::before { box-shadow: 26px 0; transform: translateX(-26px); animation: l9-1 .75s infinite linear alternate; }
    .loader::after { transform: translateX(13px) rotate(0deg) translateX(13px); animation: l9-2 .75s infinite linear alternate; }
    @keyframes l9-0 { 0%,49.9%{transform:scale(1)} 50%,100%{transform:scale(-1)} }
    @keyframes l9-1 { 100%{box-shadow:52px 0} }
    @keyframes l9-2 { 100%{transform:translateX(13px) rotate(-180deg) translateX(13px)} }
  </style>
</head>
<body>
  <div id="problem-container">
    <div id="practice-toggle-container">
      <label><input type="checkbox" id="practice-toggle"> Practice selected problems only</label>
    </div>
    <h1>F=ma Practice</h1>
    <div id="timer">03:00</div>
    <div id="exam-label"></div>
    <div id="image-wrapper"></div>
    <button id="show-prev-btn" style="margin-bottom:1em;">Show Previous Problems</button>
    <div id="previous-wrapper"></div>
    <div id="answer-box">
      <input type="text" id="answer" maxlength="1" />
      <button id="submit-btn">Submit</button>
    </div>
    <div id="feedback"></div>
  </div>

  <script>
    // practiceList will be populated by loading practice.txt
    let practiceList = [];
    async function loadPracticeList() {
      try {
        const res = await fetch('/static/practice.txt');
        const text = await res.text();
        practiceList = text.split(/[\s,]+/)
          .map(s => s.trim())
          .filter(s => s);
      } catch (e) {
        console.error('Failed to load practice.txt:', e);
      }
    }

    const config = {
      exams: ['2007','2008','2009','2010','2011','2012','2013','2014','2015','2016','2017','2018A','2018B','2019A','2019B','2020A','2020B','2021','2022A','2022B','2023','2024'],
      maxProblems: {
        '2007':38,'2008':25,'2009':25,'2010':25,'2011':25,'2012':25,'2013':25,'2014':25,'2015':25,'2016':25,'2017':25,
        '2018A':25,'2018B':25,'2019A':25,'2019B':25,'2020A':25,'2020B':25,'2021':25,
        '2022A':25,'2022B':25,'2023':25,'2024':25
      }
    };

    let currentExam, currentNum, answerLines = [];
    let timeLeft = 180, timerInterval = null;

    function updateTimerDisplay() {
      const el = document.getElementById('timer');
      if (timeLeft <= 0) { el.textContent = 'OVERTIME'; el.style.color = 'red'; }
      else {
        const m = String(Math.floor(timeLeft/60)).padStart(2,'0');
        const s = String(timeLeft%60).padStart(2,'0');
        el.textContent = `${m}:${s}`;
        el.style.color = '#333';
      }
    }
    function startTimer() {
      clearInterval(timerInterval);
      timeLeft = 180;
      updateTimerDisplay();
      timerInterval = setInterval(() => {
        timeLeft--;
        updateTimerDisplay();
        if (timeLeft <= 0) clearInterval(timerInterval);
      }, 1000);
    }

    async function fetchImageParts(exam, num) {
      const base = `/static/images/fma/${exam}/${num}`;
      const ext = '.webp';
      const parts = [];
      for (let sfx of ['a','b']) {
        try {
          const url = `${base}${sfx}${ext}`;
          if ((await fetch(url, { method: 'HEAD' })).ok) parts.push(url);
        } catch {}
      }
      if (!parts.length) {
        try {
          const url = `${base}${ext}`;
          if ((await fetch(url, { method: 'HEAD' })).ok) parts.push(url);
        } catch {}
      }
      return parts;
    }

    function preloadNeighborhood(exam, center) {
      const candidates = [center-2, center-1, center+1]
        .filter((n, i, arr) => n >= 1 && n <= config.maxProblems[exam] && arr.indexOf(n) === i);
      candidates.forEach(num => {
        ['a','b',''].forEach(sfx => {
          const suffix = sfx ? sfx : '';
          const url = `/static/images/fma/${exam}/${num}${suffix}.webp`;
          const img = new Image();
          img.src = url;
        });
      });
    }

    async function loadRandomProblem() {
      document.getElementById('previous-wrapper').style.display = 'none';
      document.getElementById('show-prev-btn').textContent = 'Show Previous Problems';

      const wrapper = document.getElementById('image-wrapper');
      wrapper.innerHTML = '<div class="loader"></div>';

      let imgs = [];
      while (!imgs.length) {
        if (document.getElementById('practice-toggle').checked && practiceList.length) {
          const entry = practiceList[Math.floor(Math.random() * practiceList.length)];
          const [exam, numStr] = entry.split('.');
          currentExam = exam;
          currentNum = parseInt(numStr, 10);
        } else {
          currentExam = config.exams[Math.floor(Math.random() * config.exams.length)];
          currentNum = Math.floor(Math.random() * config.maxProblems[currentExam]) + 1;
        }
        imgs = await fetchImageParts(currentExam, currentNum);
      }

      document.getElementById('exam-label').textContent = `Exam ${currentExam} #${currentNum}`;
      wrapper.innerHTML = '';
      imgs.forEach(src => {
        const img = document.createElement('img');
        img.src = src;
        img.alt = `F=ma ${currentExam} #${currentNum}`;
        img.className = 'problem-image';
        wrapper.appendChild(img);
      });

      document.getElementById('answer').value = '';
      document.getElementById('feedback').textContent = '';
      document.getElementById('submit-btn').textContent = 'Submit';
      try {
        const keyTxt = await (await fetch(`/static/images/fma/${currentExam}/key.txt`)).text();
        answerLines = keyTxt.split(/\r?\n/).map(l => l.trim().toUpperCase()).filter(l => l);
      } catch {}

      preloadNeighborhood(currentExam, currentNum);
      startTimer();
    }

    window.addEventListener('DOMContentLoaded', async () => {
      await loadPracticeList();
      document.getElementById('show-prev-btn').addEventListener('click', async function() {
        const pw = document.getElementById('previous-wrapper');
        if (pw.style.display === 'none') {
          pw.innerHTML = '';
          const sections = [];
          for (let i = currentNum - 2; i < currentNum; i++) {
            if (i >= 1) {
              const secDiv = document.createElement('div'); secDiv.className = 'prev-section';
              const title = document.createElement('div'); title.className = 'prev-title'; title.textContent = `${i}`;
              secDiv.appendChild(title);
              const imgs = await fetchImageParts(currentExam, i);
              imgs.forEach(src => { const img = document.createElement('img'); img.src = src; img.alt = `F=ma ${currentExam} #${i}`; img.className = 'problem-image'; secDiv.appendChild(img); });
              sections.push(secDiv);
            }
          }
          if (sections.length) sections.forEach(sec => pw.appendChild(sec));
          else pw.textContent = 'No previous problems available.';
          pw.style.display = 'block'; this.textContent = 'Hide Previous Problems';
        } else { pw.style.display = 'none'; this.textContent = 'Show Previous Problems'; }
      });
      loadRandomProblem();
    });

    document.getElementById('submit-btn').addEventListener('click', async function() {
      const btn = this, fb = document.getElementById('feedback'), ans = document.getElementById('answer').value.toUpperCase().trim();
      if (btn.textContent === 'Submit') {
        if (!/^[A-E]$/.test(ans)) { fb.textContent = 'Please enter A, B, C, D, or E.'; fb.style.color = 'darkorange'; return; }
        const raw = answerLines[currentNum - 1] || '', correct = raw.split('').filter(c => /[A-E]/.test(c));
        if (correct.includes(ans)) { fb.textContent = '✅ Correct!'; fb.style.color = 'green'; }
        else { fb.textContent = `❌ Incorrect — the right answer${correct.length>1?'s are':' is'} ${correct.join(' & ')}.`; fb.style.color = 'red'; }
        btn.textContent = 'Next Question';
      } else { await loadRandomProblem(); }
    });
  </script>
</body>
</html>
